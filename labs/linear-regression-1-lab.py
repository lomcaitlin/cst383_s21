import numpy as npimport pandas as pdfrom matplotlib import rcParamsimport seaborn as snsfrom scipy.stats import zscoreimport matplotlib.pyplot as pltfrom sklearn.model_selection import train_test_splitfrom sklearn.preprocessing import StandardScalerfrom sklearn.neighbors import KNeighborsRegressorfrom sklearn.linear_model import LinearRegression# 1 : read datadf = pd.read_csv("https://raw.githubusercontent.com/grbruns/cst383/master/machine.csv")df.index = df['vendor']+' '+df['model']df.drop(['vendor', 'model'], axis=1, inplace=True)df['cs'] = np.round(1e3/df['myct'], 2)	# clock speed in MHz (millions of cycles/sec)df.info()# 3 : create matrix of scatter plots to look at correlation between featuressns.pairplot(df)# 4a : pick a feature for x and prp for y axis on scatterplotsns.scatterplot(x='erp', y='prp', data=df)# 4b : describe the patternthis pattern is overall pretty linear. it has a positive correlation.one outlier I see is the one where erp is ~ 125 and prp is ~ 390# 5 : fit a linear model using LinearRegression with prp as target variableX = df[['erp']].valuesy = df['prp'].valuesfit = LinearRegression()fit.fit(X,y)predicted = fit.predict(X)# 6 : plot predicted relationship# ?????? how sns.scatterplot(x=df['erp'], y=df['prp'])plt.plot(X,predicted, color="darkred")# 7 : compare predicted v actual valuessns.scatterplot(x=df['prp'].values, y=predicted)sns.regplot(x=df['prp'].values, y=pred)# if predictions were correct, it'd be a straight diagonal line