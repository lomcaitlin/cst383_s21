import numpy as npimport pandas as pdfrom matplotlib import rcParamsimport seaborn as snsfrom scipy.stats import zscoreimport matplotlib.pyplot as pltfrom sklearn.model_selection import train_test_splitfrom sklearn.preprocessing import StandardScalerfrom sklearn.neighbors import KNeighborsRegressorfrom sklearn.linear_model import LinearRegression# 1 : read CPU datadf = pd.read_csv("https://raw.githubusercontent.com/grbruns/cst383/master/machine.csv")df.index = df['vendor']+' '+df['model']df.drop(['vendor', 'model'], axis=1, inplace=True)df['cs'] = np.round(1e3/df['myct'], 2)	# clock speed in MHz # 2 : set predictor variablespredictors = ['cach', 'myct']	# YOUR CODE HEREtarget = 'prp'			# YOUR CODE HEREX = df[predictors].valuesy = df[target].values# 3 : split data randomly into training set using 70/30X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.30, random_state=42)# 4 : create linear model to predict performancereg = LinearRegression()reg.fit(X_train, y_train)y_predict = reg.predict(X_test)# 5 : compute test RMSEtest_rmse = np.sqrt((y_predict - y_test)**2).mean()test_rmse # 86.29317458650809# 6 : repeat 2-4 to see how much the RMSE changesX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.30, random_state=0)reg = LinearRegression()reg.fit(X_train, y_train)y_predict = reg.predict(X_test)test_rmse = np.sqrt((y_predict - y_test)**2).mean()test_rmse # 49.80861660137236# 7 : repeat 2-4 100 times, each time creating different training/test sets.# collect computed rmse values and plot on histogramX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.30)reg = LinearRegression()reg.fit(X_train, y_train)y_predict = reg.predict(X_test)test_rmse = np.sqrt((y_predict - y_test)**2).mean()